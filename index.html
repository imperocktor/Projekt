<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AfD-das Spiel</title>
<style>
body { margin:0; overflow:hidden; background:#fff; display:flex; flex-direction:column; align-items:center; justify-content:center; font-family:Arial,sans-serif; height:100vh; }
#gameCanvas { background:#fff; border:1px solid black; outline:none; }
#scoreboard,#levelboard,#bombCooldownDisplay,#lifeboard{
  margin-top:10px; font-size:24px; color:white;
  background:rgba(0,0,0,0.6); padding:6px 15px; border-radius:10px;
  font-weight:bold; box-shadow:0 2px 6px rgba(0,0,0,0.4);
}
#gameTitle { font-size:36px; font-weight:bold; text-align:center; margin-bottom:20px; }
#gameTitle span { font-size:40px; }
#gameTitle .AfD { color:blue; } #gameTitle .das { color:red; } #gameTitle .Spiel { color:blue; } #gameTitle .! { color:red; }
#gameOverModal { display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.8); padding:30px; border-radius:10px; color:white; text-align:center; box-shadow:0 4px 12px rgba(0,0,0,0.5); z-index:1000; }
#gameOverModal h1 { font-size:32px; margin-bottom:20px; }
#gameOverModal button { background:#009ADA; color:white; font-size:18px; padding:10px 20px; border:none; border-radius:5px; cursor:pointer; transition:0.3s; }
#gameOverModal button:hover { background:#007b8a; }
#gameDescription { margin-top:10px; font-size:14px; color:black; background:rgba(255,255,255,0.7); padding:8px 15px; border-radius:5px; max-width:90%; text-align:center; box-shadow:0 2px 6px rgba(0,0,0,0.3); }
#characterSelectorContainer { margin-top:15px; font-size:16px; }
#characterSelector { font-size:16px; padding:4px 8px; }
</style>
</head>
<body>

<div id="gameTitle">
<span class="AfD">AfD</span> <span class="das">das</span> <span class="Spiel">Spiel</span> <span class="!">!</span>
</div>

<canvas id="gameCanvas" tabindex="0"></canvas>
<div id="scoreboard">Punkte: <span id="score">0</span></div>
<div id="lifeboard">Leben: <span id="lives">3</span></div>
<div id="levelboard">Level: <span id="level">1</span></div>
<div id="bombCooldownDisplay">Handgranate bereit!</div>

<div id="gameOverModal">
<h1>Spiel verloren!</h1>
<button id="restartButton">Neu starten</button>
</div>

<div id="gameDescription">
Sammle Punkte, indem du Alice in der Stretch-Funktion (Pfeiltaste oben) einsammelst.<br>
Doppelsprung-Funktion mit Leertaste!<br>
Alle 10 Punkte erhöht sich die Spielgeschwindigkeit!<br>
Weiche schlechten Politikern aus, sonst verlierst du das Spiel!<br>
Handgranaten: Pfeiltaste unten, 10 Sek. Cooldown, nur Bonusgegner zerstören.<br>
</div>

<div id="characterSelectorContainer">
Spielfigur auswählen: 
<select id="characterSelector">
<option value="assets/spielfigur1.png">Spielfigur 1</option>
<option value="assets/spielfigur2.png">Spielfigur 2</option>
</select>
</div>

<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
const scoreElement=document.getElementById('score');
const livesElement=document.getElementById('lives');
const levelElement=document.getElementById('level');
const gameOverModal=document.getElementById('gameOverModal');
const restartButton=document.getElementById('restartButton');
const characterSelector=document.getElementById('characterSelector');
const bombCooldownDisplay=document.getElementById('bombCooldownDisplay');

canvas.width=Math.min(window.innerWidth,1200);
canvas.height=Math.min(window.innerHeight,600);

// ---------------- Spieler ----------------
const playerImage=new Image();
playerImage.src='assets/spielfigur1.png';
let player={x:50,y:canvas.height-50,width:50,height:50,originalHeight:50,speed:5,dx:0,dy:0,gravity:0.8,jumpPower:-12,grounded:false,jumps:0,maxJumps:2,isStretched:false};

// Boden
const groundHeight=50;
const floorOffset=10;
const platforms=[{x:0,y:canvas.height-groundHeight,width:canvas.width,height:groundHeight}];

// Steuerung
let rightPressed=false,leftPressed=false,upPressed=false;
let gamePaused=false;

// Sounds
const jumpSound=new Audio('sounds/Jump.MP3');
const stretchSound=new Audio('sounds/stretch.mp3');
function safePlay(audio){audio.currentTime=0; audio.volume=0.6; audio.play().catch(()=>{});}

// ---------------- Spielereingaben ----------------
document.addEventListener('keydown',keyDownHandler);
document.addEventListener('keyup',keyUpHandler);

function keyDownHandler(e){
    if(e.key=='ArrowRight') rightPressed=true;
    else if(e.key=='ArrowLeft') leftPressed=true;
    else if(e.key=='ArrowUp'){
        upPressed=true;
        if(!player.isStretched){
            player.height=player.originalHeight*1.5;
            player.isStretched=true;
            player.y-=(player.height-player.originalHeight);
            safePlay(stretchSound);
        }
    }
    else if(e.key==' '){
        if(player.grounded||player.jumps<player.maxJumps){
            player.dy=player.jumpPower;
            player.jumps++;
            player.grounded=false;
            safePlay(jumpSound);
        }
    }
    else if(e.key=='Enter'&&gameOverModal.style.display==='block') resetGame();
}

function keyUpHandler(e){
    if(e.key=='ArrowRight') rightPressed=false;
    else if(e.key=='ArrowLeft') leftPressed=false;
    else if(e.key=='ArrowUp' && player.isStretched){
        player.y += (player.height-player.originalHeight);
        player.height=player.originalHeight;
        player.isStretched=false;
    }
}

// Spielfigur wechseln
characterSelector.addEventListener('change',function(){
    playerImage.src=this.value;
    player.width=50; player.height=50; player.originalHeight=50;
    player.y=canvas.height-groundHeight-player.height + floorOffset;
    player.isStretched=false; player.dy=0; canvas.focus();
});

// ---------------- Hintergrundmusik ----------------
const mp3Files=['assets/mp3/song1.mp3','assets/mp3/song2.mp3','assets/mp3/song3.mp3'];
const audioPlayer=new Audio();
function playRandomSong(){
    if(audioPlayer.paused){
        const r=Math.floor(Math.random()*mp3Files.length);
        audioPlayer.src=mp3Files[r];
        audioPlayer.play().catch(()=>{});
    }
}

// ---------------- Hintergrundbilder ----------------
const backgrounds=['assets/hintergrund1.png','assets/hintergrund2.png','assets/hintergrund3.png'];
const backgroundImage=new Image();
function setRandomBackground(){
    const r=Math.floor(Math.random()*backgrounds.length);
    backgroundImage.src=backgrounds[r];
}

// ---------------- Hindernisse & Bonusgegner & Supergegner ----------------
const normalObstacleWidth=60,normalObstacleHeight=60;
const werbungWidth=200,werbungHeight=100;
const bonusWidth=60,bonusHeight=100;
const superWidth=300, superHeight=133; // Supergegner Größe
const obstacles=[];

// Bilder laden
const obstacleImages=['objekt1.png','objekt2.png','objekt3.png','objekt4.png','objekt5.png','objekt6.png','objekt7.png','objekt8.png'];
const loadedObstacleImages=[]; 
obstacleImages.forEach(img=>{const im=new Image(); im.src='assets/'+img; loadedObstacleImages.push(im);});

const werbungImages=['werbung1.png','werbung2.png'];
const loadedWerbungImages=[]; 
werbungImages.forEach(img=>{const im=new Image(); im.src='assets/werbung/'+img; loadedWerbungImages.push(im);});

const bonusImages=['bonusgegner1.png','bonusgegner2.png','bonusgegner3.png','bonusgegner4.png'];
const loadedBonusImages=[]; 
bonusImages.forEach(img=>{const im=new Image(); im.src='assets/bonusgegner/'+img; loadedBonusImages.push(im);});

const superImages=['supergegner1.png','supergegner2.png']; 
const loadedSuperImages=[]; 
superImages.forEach(img=>{const im=new Image(); im.src='assets/supergegner/'+img; loadedSuperImages.push(im);});

// ---------------- Explosionen ----------------
const explosions=[];
function createPointExplosion(x, y, points){
    explosions.push({
        x, y, points, alpha:1, scale:0.5,
        vy: points.startsWith("+") ? -1.5 : 0,
        vx: (Math.random()-0.5)*1.5,
        rotation: (Math.random()-0.5)*0.2,
        shakePhase: 0
    });
}

// ---------------- Score / Level / Leben ----------------
let score=0, level=1, lives=3;
let obstacleSpeedBase=3, obstacleSpeed=3;


// ---------------- Sounds für Objekte ----------------
function playObjectSoundByName(image){
    if(!image || !image.src) return;
    const filename=image.src.split('/').pop().split('.')[0];
    const audio=new Audio(`sounds/${filename}.mp3`);
    audio.volume=0.5;
    audio.play().catch(()=>{});
}

// ---------------- Spieler bewegen ----------------
function movePlayer(){
    player.dx=0;
    if(rightPressed) player.dx=player.speed;
    if(leftPressed) player.dx=-player.speed;
    if(!player.grounded) player.dy+=player.gravity; else player.dy=0;
    player.x+=player.dx; player.y+=player.dy;

    const floor=canvas.height-groundHeight-player.height+floorOffset;
    if(player.y>floor){player.y=floor; player.grounded=true; player.jumps=0;}
    if(player.x<0) player.x=0;
    if(player.x+player.width>canvas.width) player.x=canvas.width-player.width;
}

// ---------------- Hindernisse erzeugen ----------------
function checkCollision(p,o){return p.x<o.x+o.width&&p.x+p.width>o.x&&p.y<o.y+o.height&&p.y+p.height>o.y;}


// ---------------- Bonus-, Super- & normale Objekte ----------------
let lastBonusTime = 0;
const bonusInterval = 20000; // 20 Sekunden

let lastSuperTime = 0;
const superInterval = 60000; // 60 Sekunden

let nextObstacleTime = Date.now() + Math.random() * 2000 + 1000;

// ---------------- Hindernisse erzeugen ----------------
function spawnObstacles() {
    const now = Date.now();

    // --- Bonusgegner alle 20s ---
    if (now - lastBonusTime >= bonusInterval) {
        const img = loadedBonusImages[Math.floor(Math.random() * loadedBonusImages.length)];
        const baseY = canvas.height - groundHeight - bonusHeight;
        obstacles.push({
            x: canvas.width,
            y: baseY,
            baseY: baseY,
            width: img.width,
            height: img.height,
            image: img,
            isBonus: true,
            floatPhase: Math.random() * Math.PI * 2,
            glowPulse: Math.random() * Math.PI * 2
        });
        playObjectSoundByName(img);
        lastBonusTime = now;
    }

    // --- Supergegner alle 60s ---
    if (now - lastSuperTime >= superInterval) {
        const img = loadedSuperImages[Math.floor(Math.random() * loadedSuperImages.length)];
        obstacles.push({
            x: canvas.width,
            y: canvas.height - groundHeight - img.height + floorOffset,
            width: img.width,
            height: img.height,
            image: img,
            isSuper: true,
            dx: -(obstacleSpeed + 1)
        });
        playObjectSoundByName(img);
        lastSuperTime = now;
    }

    // --- Normale Objekte zufällig 1–3s ---
    if (now >= nextObstacleTime) {
        const randomIndex = Math.floor(Math.random() * loadedObstacleImages.length);
        const img = loadedObstacleImages[randomIndex];
        const isAlice = (randomIndex === 0);
        const targetY = isAlice ? canvas.height - groundHeight - 60 : canvas.height - groundHeight - normalObstacleHeight;

        obstacles.push({
            x: canvas.width,
            y: targetY,
            width: normalObstacleWidth,
            height: normalObstacleHeight,
            image: img,
            isCollectible: isAlice,
            rotation: 0,
            rotationSpeed: 0.1,
            isWerbung: false,
            isBonus: false
        });
        playObjectSoundByName(img);

        nextObstacleTime = now + 1000 + Math.random() * 2000;
    }
}

// ---------------- Obstacles bewegen & Kollision ----------------
function moveObstacles() {
    spawnObstacles();

    for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        // Bewegung
        if (o.isSuper) o.x += o.dx;
        else o.x -= obstacleSpeed;

        // Kollision prüfen
        if (checkCollision(player, o)) {
            if (o.isCollectible) {
                if (player.isStretched) {
                    score++;
                    scoreElement.textContent = score;
                    createPointExplosion(o.x + o.width / 2, o.y, "+1");
                    playRandomSong();
                    if (score % 10 === 0) {
                        level++;
                        levelElement.textContent = level;
                        obstacleSpeed += 0.5;
                    }
                    obstacles.splice(i, 1);
                }
                continue;
            }

            if (o.isBonus) {
                lives++;
                livesElement.textContent = lives;
                obstacles.splice(i, 1);
                continue;
            }

            if (o.isSuper) {
                lives--;
                livesElement.textContent = lives;
                createPointExplosion(player.x + player.width / 2, player.y, "-1 Leben");
                obstacles.splice(i, 1);
                if (lives <= 0) gameOver();
                continue;
            }

            if (!o.isWerbung) {
                lives--;
                livesElement.textContent = lives;
                createPointExplosion(player.x + player.width / 2, player.y, "-1 Leben");
                obstacles.splice(i, 1);
                if (lives <= 0) gameOver();
            }
        }

        if (o.x + o.width < 0) obstacles.splice(i, 1);
    }
}





// ---------------- Hindernisse erzeugen ----------------
function createObstacle() {
    const now = Date.now();
    let img;

    // --- Bonusgegner alle 20s ---
    if (now - lastBonusTime >= bonusInterval) {
        img = loadedBonusImages[Math.floor(Math.random() * loadedBonusImages.length)];
        const baseY = canvas.height - groundHeight - bonusHeight;
        obstacles.push({
            x: canvas.width,
            y: baseY,
            baseY: baseY,
            width: img.width,
            height: img.height,
            image: img,
            isBonus: true,
            floatPhase: Math.random() * Math.PI * 2,
            glowPulse: Math.random() * Math.PI * 2
        });
        playObjectSoundByName(img);
        lastBonusTime = now;
        return; // nur ein Objekt pro Aufruf
    }

    // --- Supergegner alle 60s ---
    if (now - lastSuperTime >= superInterval) {
        img = loadedSuperImages[Math.floor(Math.random() * loadedSuperImages.length)];
        obstacles.push({
            x: canvas.width,
            y: canvas.height - groundHeight - img.height + floorOffset,
            width: img.width,
            height: img.height,
            image: img,
            isSuper: true,
            dx: -(obstacleSpeed + 1)
        });
        playObjectSoundByName(img);
        lastSuperTime = now;
        return; // nur ein Objekt pro Aufruf
    }

    // --- Normale Objekte zufällig ---
    const randomIndex = Math.floor(Math.random() * loadedObstacleImages.length);
    img = loadedObstacleImages[randomIndex];
    const isAlice = (randomIndex === 0);
    const targetY = isAlice ? canvas.height - groundHeight - 60 : canvas.height - groundHeight - normalObstacleHeight;

    obstacles.push({
        x: canvas.width,
        y: targetY,
        width: normalObstacleWidth,
        height: normalObstacleHeight,
        image: img,
        isCollectible: isAlice,
        rotation: 0,
        rotationSpeed: 0.1,
        isWerbung: false,
        isBonus: false
    });
    playObjectSoundByName(img);
}

// ---------------- Hindernisse bewegen & Kollision ----------------
function moveObstacles(){
    const now = Date.now();
    if(!gamePaused && now>nextObstacleTime){
        createObstacle();
        nextObstacleTime = now + Math.random()*2000+1000;
    }

    for(let i=obstacles.length-1;i>=0;i--){
        const o=obstacles[i];
        if(o.isSuper) o.x += o.dx;
        else o.x -= obstacleSpeed;

        if(checkCollision(player,o)){
        if(o.isCollectible){
    if(player.isStretched){
        score++; 
        scoreElement.textContent=score;
        createPointExplosion(o.x+o.width/2,o.y,"+1");

        // Zufälligen Song abspielen
        playRandomSong();

        if(score%10===0){ 
            level++; 
            levelElement.textContent=level; 
            obstacleSpeed+=0.5;
        }
        obstacles.splice(i,1);
        continue;
    } else continue;
}
            if(o.isBonus){ gameOver(); return;}
            if(o.isWerbung) continue;
            if(o.isSuper){
                lives--; livesElement.textContent=lives;
                createPointExplosion(player.x+player.width/2,player.y,"-1 Leben");
                obstacles.splice(i,1);
                if(lives<=0){ gameOver(); break; }
                continue;
            }
            lives--; livesElement.textContent=lives;
            createPointExplosion(player.x+player.width/2,player.y,"-1 Leben");
            obstacles.splice(i,1);
            if(lives<=0){ gameOver(); break; }
        }

        if(o.x+o.width<0) obstacles.splice(i,1);
    }
}
// ---------------- Handgranaten aktualisieren (Bonusgegner zerstören) ----------------
const bombsArr=[], bombSize=20, bombFallSpeed=5, bombExplosionRadius=80, bombCooldown=10000; 
let lastBombTime=-bombCooldown;
const beep1=new Audio('sounds/beep1.mp3'), beep2=new Audio('sounds/beep2.mp3'), beep3=new Audio('sounds/beep3.mp3'), bombSound=new Audio('sounds/handgranate.mp3');
const smokeParticles=[];

function createSmoke(x,y){smokeParticles.push({x,y,radius:Math.random()*5+5,alpha:0.5,vy:-1-(Math.random()),vx:(Math.random()-0.5)*1,life:50,color:'gray'});}
function updateSmoke(){for(let i=smokeParticles.length-1;i>=0;i--){const s=smokeParticles[i]; s.x+=s.vx;s.y+=s.vy;s.alpha-=0.01;s.radius*=0.98;s.life--; if(s.alpha<=0||s.life<=0) smokeParticles.splice(i,1);}}
function drawSmoke(){smokeParticles.forEach(s=>{ctx.save();ctx.globalAlpha=s.alpha; ctx.fillStyle=s.color; ctx.beginPath(); ctx.arc(s.x,s.y,s.radius,0,Math.PI*2); ctx.fill(); ctx.restore();});}

const handgrenadeImg=new Image(); handgrenadeImg.src='assets/handgranate.png';
document.addEventListener('keydown',function(e){
    if(e.key==='ArrowDown'){
        const now=Date.now(); 
        if(now-lastBombTime>=bombCooldown){
            bombsArr.push({x:player.x+player.width/2-bombSize/2,y:player.y+player.height,width:bombSize,height:bombSize,exploded:false,timer:180,beepPhase:0}); 
            lastBombTime=now;
        }
    }
});

function updateBombs(){
    for(let i=bombsArr.length-1;i>=0;i--){
        const b=bombsArr[i];
        if(!b.exploded){
            if(b.y+b.height<canvas.height-groundHeight){b.y+=bombFallSpeed; createSmoke(b.x+b.width/2,b.y);}
            b.timer--; 
            if(b.timer<=60 && b.beepPhase===0){beep1.play(); b.beepPhase=1;} 
            else if(b.timer<=45 && b.beepPhase===1){beep2.play(); b.beepPhase=2;} 
            else if(b.timer<=30 && b.beepPhase===2){beep3.play(); b.beepPhase=3;}
            if(b.timer<=0){b.exploded=true; bombSound.play();}
        }else{
            const phase=180-b.timer; 
            const radius=bombExplosionRadius*(phase/30);
            ctx.save(); ctx.globalAlpha=1-(phase/30); ctx.fillStyle='orange'; ctx.beginPath(); ctx.arc(b.x+b.width/2,b.y+b.height/2,radius,0,Math.PI*2); ctx.fill(); ctx.restore();
            for(let j=0;j<3;j++){createSmoke(b.x+b.width/2+(Math.random()-0.5)*50,b.y+b.height/2+(Math.random()-0.5)*50);}
            obstacles.forEach((o,index)=>{
                if(o.isBonus){
                    const dx=(b.x+b.width/2)-(o.x+o.width/2);
                    const dy=(b.y+b.height/2)-(o.y+o.height/2);
                    if(Math.sqrt(dx*dx+dy*dy)<=bombExplosionRadius){
                        lives++; livesElement.textContent=lives;
                        obstacles.splice(index,1);
                    }
                }
            });
            if(phase>30) bombsArr.splice(i,1);
        }
    }
    const remaining=Math.max(0,Math.ceil((bombCooldown-(Date.now()-lastBombTime))/1000));
    bombCooldownDisplay.textContent=remaining>0?`Handgranate bereit in ${remaining}s`:'Handgranate bereit!';
}
function drawBombs(){bombsArr.forEach(b=>{if(!b.exploded) ctx.drawImage(handgrenadeImg,b.x,b.y,b.width,b.height);}); drawSmoke();}

// ---------------- Elon-Rakete ----------------
const rocketSmokeParticles=[];
function createRocketSmoke(x,y){rocketSmokeParticles.push({x,y,radius:Math.random()*12+8,alpha:0.5+Math.random()*0.3,vx:-(Math.random()*1.5+1),vy:(Math.random()-0.5)*0.5,life:110+Math.random()*40});}
function updateRocketSmoke(){for(let i=rocketSmokeParticles.length-1;i>=0;i--){const s=rocketSmokeParticles[i]; s.x+=s.vx; s.y+=s.vy; s.radius*=0.97; s.alpha*=0.985; s.life--; if(s.life<=0) rocketSmokeParticles.splice(i,1);}}
function drawRocketSmoke(){rocketSmokeParticles.forEach(s=>{ctx.save();ctx.globalAlpha=s.alpha; ctx.fillStyle='rgba(200,200,200,0.6)'; ctx.beginPath(); ctx.arc(s.x,s.y,s.radius,0,Math.PI*2); ctx.fill(); ctx.restore();});}

const elonImage=new Image(); elonImage.src='assets/elon.PNG';
let elon={x:0,y:50,width:300,height:136,speed:2,direction:1,waiting:false,floatPhase:0,floatAmplitude:10,glowPhase:0};
function drawElon(){
    elon.floatPhase+=0.1;
    const floatY=Math.sin(elon.floatPhase)*elon.floatAmplitude+Math.sin(elon.floatPhase*1.7+1)*elon.floatAmplitude/2;
    ctx.save();
    ctx.translate(elon.x, elon.y+floatY);
    if(elon.direction===-1){ctx.translate(elon.width,0); ctx.scale(-1,1);}
    elon.glowPhase+=0.1; const glowPower=10+Math.sin(elon.glowPhase)*5;
    ctx.shadowColor='red'; ctx.shadowBlur=glowPower; ctx.shadowOffsetX=0; ctx.shadowOffsetY=0;
    ctx.drawImage(elonImage,0,0,elon.width,elon.height);
    const smokeX=elon.width*0.27, smokeY=elon.height*0.5;
    createRocketSmoke(smokeX, smokeY);
    updateRocketSmoke(); drawRocketSmoke();
    ctx.restore();
    if(!elon.waiting){elon.x+=elon.speed*elon.direction;
        if((elon.direction===1&&elon.x>canvas.width)||(elon.direction===-1&&elon.x+elon.width<0)){
            elon.waiting=true; setTimeout(()=>{elon.direction*=-1; elon.x=elon.direction===1?-elon.width:canvas.width; elon.waiting=false;},2000);
        }
    }
}

// ---------------- Spiel zurücksetzen ----------------
function resetGame(){
    player.x=50; player.y=canvas.height-player.height-groundHeight+floorOffset;
    player.dx=0; player.dy=0; player.jumps=0; player.grounded=false; player.isStretched=false;
    obstacles.length=0; bombsArr.length=0;
    score=0; scoreElement.textContent=score;
    level=1; levelElement.textContent=level;
    lives=3; livesElement.textContent=lives;
    gameOverModal.style.display='none';
    obstacleSpeed=obstacleSpeedBase; gamePaused=false; nextObstacleTime=Date.now()+Math.random()*2000+1000;
    setRandomBackground();
    setRandomWeather();
    canvas.focus();
    gameLoop();
}
function gameOver(){gameOverModal.style.display='block'; gamePaused=true;}
restartButton.addEventListener('click',resetGame);

// ---------------- Wetter-System ----------------
let weatherType = null, weatherParticles = [], maxWeatherParticles = 150, wind = 0, windTarget = 0, windChangeSpeed = 0.002, thunderTimer = 0, thunderFlash = false;
const thunderSounds = [new Audio('sounds/thunder1.mp3'), new Audio('sounds/thunder2.mp3'), new Audio('sounds/thunder3.mp3')];
function playThunderSound(){const thunder = thunderSounds[Math.floor(Math.random()*thunderSounds.length)]; const delay = 200+Math.random()*800; setTimeout(()=>{thunder.volume=0.6; thunder.play().catch(()=>{});},delay);}
function setRandomWeather(){
    const r=Math.random();
    if(r<0.25) weatherType=null;
    else if(r<0.5) weatherType='rain';
    else if(r<0.8) weatherType='snow';
    else weatherType='thunder';
    if(!weatherType){ weatherParticles=[]; return; }
    maxWeatherParticles = weatherType==='snow'?100+Math.random()*50:150+Math.random()*100;
    wind=(Math.random()-0.5)*2; windTarget=wind;
    weatherParticles=[];
    for(let i=0;i<maxWeatherParticles;i++){
        weatherParticles.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,speedY:weatherType==='rain'?4+Math.random()*4:1+Math.random()*2,size:weatherType==='rain'?2:3+Math.random()*3,rotation:Math.random()*Math.PI*2,rotationSpeed:Math.random()*0.02-0.01});
    }
    thunderTimer=weatherType==='thunder'?100+Math.random()*200:0;
}
function updateWeather(){
    if(!weatherType) return;
    wind+=(windTarget-wind)*windChangeSpeed;
    if(Math.abs(wind-windTarget)<0.01) windTarget=(Math.random()-0.5)*2*(1+(level-1)*0.05);
    for(let p of weatherParticles){p.y+=p.speedY; p.x+=wind; if(weatherType==='snow') p.rotation+=p.rotationSpeed; if(p.y>canvas.height){p.y=-10; p.x=Math.random()*canvas.width;} if(p.x<0)p.x=canvas.width; if(p.x>canvas.width)p.x=0;}
    if(weatherType==='thunder'){thunderTimer--; if(thunderTimer<=0){thunderFlash=true; playThunderSound(); setTimeout(()=>{thunderFlash=false; thunderTimer=Math.max(50,100-(level-1)*5)+Math.random()*100;},100+Math.random()*200);}}
}
function drawWeather(){
    if(!weatherType) return;
    if(thunderFlash){ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fillRect(0,0,canvas.width,canvas.height);}
    let intensityMultiplier=1+(level-1)*0.1;
    ctx.save();
    for(let p of weatherParticles){
        let px=p.x, py=p.y;
        if(weatherType==='rain'||weatherType==='thunder'){ctx.strokeStyle='rgba(173,216,230,0.6)'; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px,py+p.size*5*intensityMultiplier); ctx.stroke();}
        else if(weatherType==='snow'){ctx.save(); ctx.translate(px,py); ctx.rotate(p.rotation); ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(0,0,p.size*intensityMultiplier,0,Math.PI*2); ctx.fill(); ctx.restore();}
    }
    ctx.restore();
}

// ---------------- Zeichnen & Loop ----------------
function drawPlayer(){ctx.drawImage(playerImage,player.x,player.y,player.width,player.height);}
function drawBackground(){ctx.drawImage(backgroundImage,0,0,canvas.width,canvas.height);}
function drawGround(){const stripeWidth=40,stripeHeight=5,stripeGap=20; ctx.fillStyle='#2f2f2f'; platforms.forEach(p=>{ctx.fillRect(p.x,p.y,p.width,p.height); for(let x=p.x;x<p.x+p.width;x+=stripeWidth+stripeGap){ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(x,p.y+p.height/2-stripeHeight/2,stripeWidth,stripeHeight);}});}
function drawObstacles(){const time=Date.now(); obstacles.forEach(o=>{let drawY=o.y+floorOffset; if(o.isBonus){o.floatPhase+=0.08; const hopHeight=15; const floatY=Math.sin(o.floatPhase)*hopHeight; o.y=o.baseY-floatY; ctx.save(); ctx.shadowColor='gold'; ctx.shadowBlur=10; ctx.drawImage(o.image,o.x,drawY,o.width,o.height); ctx.restore();}
else if(o.isSuper){ctx.drawImage(o.image,o.x,drawY,o.width,o.height);}
else if(!o.isWerbung && !o.isBonus){o.rotation+=-o.rotationSpeed; ctx.save(); ctx.translate(o.x+o.width/2,drawY+o.height/2); ctx.rotate(o.rotation); ctx.drawImage(o.image,-o.width/2,-o.height/2,o.width,o.height); ctx.restore();}
else{ctx.drawImage(o.image,o.x,drawY,o.width,o.height);}});}
function drawExplosions(){for(let i=explosions.length-1;i>=0;i--){const e=explosions[i]; ctx.save(); ctx.globalAlpha=e.alpha; ctx.translate(e.x,e.y); let shakeOffsetX=0,shakeOffsetY=0; if(e.points.startsWith("-")){e.shakePhase+=0.3; shakeOffsetX=Math.sin(e.shakePhase*5)*5; shakeOffsetY=Math.sin(e.shakePhase*3)*3;} ctx.translate(shakeOffsetX,shakeOffsetY); ctx.rotate(e.rotation); ctx.fillStyle=e.points.startsWith("+")?'gold':e.points.startsWith("-")?'red':'white'; ctx.font=`${28*e.scale}px Arial`; ctx.textAlign='center'; ctx.fillText(e.points,0,0); ctx.restore(); e.y+=e.vy; e.x+=e.vx; e.alpha-=0.03; e.scale+=0.03; e.rotation+=0.05; if(e.alpha<=0) explosions.splice(i,1);}}

// ---------------- Update & Loop ----------------
function updateGameArea(){if(!gamePaused){ctx.clearRect(0,0,canvas.width,canvas.height); drawBackground(); drawGround(); movePlayer(); moveObstacles(); drawObstacles(); drawElon(); updateWeather(); drawWeather(); drawPlayer(); drawExplosions(); updateBombs(); drawBombs();}}
function gameLoop(){updateGameArea(); if(!gamePaused) requestAnimationFrame(gameLoop);}

// ---------------- Resize ----------------
window.addEventListener('resize',()=>{canvas.width=Math.min(window.innerWidth,1200); canvas.height=Math.min(window.innerHeight,600); platforms[0].y=canvas.height-groundHeight; if(player.y+player.height>canvas.height-groundHeight){player.y=canvas.height-groundHeight-player.height+floorOffset;player.grounded=true;player.jumps=0;}});

// Initialisierung
setRandomBackground(); setRandomWeather(); canvas.focus(); gameLoop();
</script>
</body>
</html>

