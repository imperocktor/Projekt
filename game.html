<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snap Alice!</title>

<style>
  /* Grund-Layout: Alles strikt untereinander und mittig */
  body { 
    margin: 0; 
    padding: 20px 0;
    overflow-x: hidden; 
    background: #ccc; 
    display: flex; 
    flex-direction: column; 
    align-items: center;    /* Dies ist das Haupt-Zentrier-Werkzeug f√ºr horizontale Mitte */
    font-family: Arial, sans-serif; 
    min-height: 100vh;
  }

  /* Titel: text-align sorgt f√ºr die Zentrierung des Inhalts */
  #gameTitle { 
    font-size: 32px; 
    font-weight: bold; 
    margin-bottom: 15px; 
    text-align: center; 
    width: 100%; /* Nimmt die volle Breite ein, um Text darin mittig zu setzen */
	color: black;
  }

  

  /* Spielfeld: display block und margin auto f√ºr absolute Zentrierung */
  #gameCanvas { 
    background: #fff; 
    border: 2px solid #333; 
    outline: none; 
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    display: block;
    margin: 0 auto;
  }

  /* Der Container f√ºr die Stats: justify-content zentriert die kleinen Boxen */
  .ui-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center; 
    gap: 10px;
    width: 100%;
    margin-top: 15px;
  }

  /* Die kleinen Anzeigen-Fenster */
  #scoreboard, #levelboard, #lifeboard, #highscoreboard, #dynamitCooldown, #grenadeCooldown {
    font-size: 18px; 
    color: white;
    background: rgba(0, 0, 0, 0.75); 
    padding: 8px 15px; 
    border-radius: 8px;
    font-weight: bold; 
    width: fit-content; 
    white-space: nowrap;
    border-bottom: 3px solid transparent;
  }

  #dynamitCooldown { border-bottom-color: #ffcc00; }
  #grenadeCooldown { border-bottom-color: #ff00ff; }

  /* Charakter-Auswahl: Ebenfalls ein Flex-Container, der sich selbst mittig setzt */
  #characterSelectorContainer { 
    margin: 20px auto; 
    padding: 10px 20px;
    background: rgba(255,255,255,0.5);
    border-radius: 10px;
    font-size: 16px; 
    font-weight: bold;
    display: flex;
    justify-content: center; 
    align-items: center;
    gap: 10px;
    width: fit-content; /* Verhindert das Ausdehnen auf volle Breite */
  }



  /* GameOver Fenster */
  #gameOverModal { 
    display: none; 
    position: absolute; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    background: rgba(0, 0, 0, 0.9); 
    padding: 30px; 
    border-radius: 15px; 
    color: white; 
    text-align: center; 
    z-index: 1000;
	
	}

</style>

</head>



<body>

<div id="gameTitle">
  Snap Alice!
</div>


<canvas id="gameCanvas" tabindex="0"></canvas>

<div class="ui-container">
  <div id="grenadeCooldown">Handgranate bereit!</div>
  <div id="dynamitCooldown">Dynamit bereit!</div>
  <div id="lifeboard">Leben: <span id="lives">3</span></div>
  <div id="scoreboard">Punkte: <span id="score">0</span></div>
  <div id="levelboard">Level: <span id="level">1</span></div>
  <div id="highscoreboard">Highscore: <span id="highscore">0</span></div>
</div>



<div id="characterSelectorContainer">
  Spielfigur ausw√§hlen: 
  <select id="characterSelector">
    <option value="assets/spielfigur1.png">Spielfigur 1</option>
    <option value="assets/spielfigur2.png">Spielfigur 2</option>
  </select>
</div>

<div id="gameOverModal">
<h1>Spiel verloren!</h1>
<button id="restartButton">Neu starten</button>
</div>










<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
const scoreElement=document.getElementById('score');
const highscoreElement = document.getElementById('highscore');
const livesElement=document.getElementById('lives');
const levelElement=document.getElementById('level');
const gameOverModal=document.getElementById('gameOverModal');
const restartButton=document.getElementById('restartButton');
const characterSelector=document.getElementById('characterSelector');
const dynamitDisplay = document.getElementById('dynamitCooldown');
const grenadeDisplay = document.getElementById('grenadeCooldown');


const FIELD_WIDTH = 1200;
const FIELD_HEIGHT = 600;

canvas.width = FIELD_WIDTH;
canvas.height = FIELD_HEIGHT;

let highscore = localStorage.getItem('highscore');
highscore = highscore ? parseInt(highscore) : 0;
highscoreElement.textContent = highscore;

// ----------------- Boing-Sound f√ºr Hoppeln -----------------
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playBoing() {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();

    oscillator.type = 'sine'; // Wellenform
    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);

    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.2);
}

let lastBoingTime = 0; // Timer, damit Sound nicht zu oft abgespielt wird




// ---------------- Titelmusik ----------------


const titelmusikFolder = 'titelmusik/';
const titelmusikFiles = [
    'titelmusik1.mp3',
    'titelmusik2.mp3',
    'titelmusik3.mp3'
    
];
const titelmusikAudio = new Audio();
titelmusikAudio.volume = 0.4; // Lautst√§rke: 0.0 bis 1.0

function playRandomTitelmusik() {
    if(titelmusikFiles.length === 0) return;
    const r = Math.floor(Math.random() * titelmusikFiles.length);
    titelmusikAudio.src = titelmusikFolder + titelmusikFiles[r];
    titelmusikAudio.loop = true; // optional: Musik wiederholen
    titelmusikAudio.play().catch(()=>{}); // Play starten, Fehler bei Autoplay ignorieren
}
let titelmusikStarted = false;

function startTitelmusik() {
    if(titelmusikStarted) return; // nur einmal starten
    titelmusikStarted = true;
    playRandomTitelmusik();
}
canvas.addEventListener('click', startTitelmusik);
document.addEventListener('keydown', startTitelmusik);

restartButton.addEventListener('click', () => {
    playRandomTitelmusik(); // Beim Reset
});










function movePlayer() {
    // Reset dx / dy
    player.dx = 0;

    // Horizontal bewegen
    if (rightPressed) player.dx = player.speed;
    if (leftPressed) player.dx = -player.speed;

    // Vertikal
    if (!player.grounded) player.dy += player.gravity;
    else player.dy = 0;

    // Bewegung anwenden
    player.x += player.dx;
    player.y += player.dy;

    // Boden pr√ºfen
    const floor = canvas.height - 50 - player.height; // 50 = groundHeight
    if (player.y > floor) {
        player.y = floor;
        player.grounded = true;
        player.jumps = 0;
    }

    // Bildschirmgrenzen
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

    // H√ºpfen / Boing-Sound
    if ((rightPressed || leftPressed) && player.grounded) {
        hopping = true;
        hopPhase += 0.6; // Geschwindigkeit der H√ºpfen-Animation
        const now = Date.now();
        if (now - lastBoingTime > 100) {
            playBoing();
            lastBoingTime = now;
        }
    } else {
        hopping = false;
        hopPhase = 0;
    }
}




let hopping = false;
let hopPhase = 0, hopSpeed = 0.6, hopHeight = 6;

const groundHeight=50;
const floorOffset=10;
const platforms=[{x:0,y:canvas.height-groundHeight,width:canvas.width,height:groundHeight}];

let rightPressed=false,leftPressed=false,upPressed=false;
let gamePaused=false;






function keyDownHandler(e) {

    if (['ArrowUp','ArrowRight',' '].includes(e.key)) {
        e.preventDefault();
    }

    const key = e.key.toLowerCase();
    const now = Date.now();

    // Bewegung
    if (key === 'd') rightPressed = true;
    else if (key === 'a') leftPressed = true;

    // Springen
    else if (e.key === ' ') {
        if (player.grounded || player.jumps < player.maxJumps) {
            player.dy = player.jumpPower;
            player.jumps++;
            player.grounded = false;
            safePlay(jumpSound);
        }
    }

    // Stretch
    else if (e.key === 'ArrowRight') {
        if (!player.isStretched) {
            player.height = player.originalHeight * 1.5;
            player.isStretched = true;
            player.y -= (player.height - player.originalHeight);
        }
    }

    // MP40
    else if (e.key === 'ArrowUp') {
        if (!isShooting) {
            isShooting = true;
            mp40Sound.currentTime = 0;
            mp40Sound.play();
        }
    }

    // Dynamit (E)
    else if (key === 'e') {
        if (now - lastBombTime >= bombCooldown) {
            bombsArr.push({
                x: player.x,
                y: player.y,
                width: dynamitImg.naturalWidth,
                height: dynamitImg.naturalHeight,
                exploded: false,
                explosionFrame: 0,
                damageDone: false,
                spawnTime: now
            });
            lastBombTime = now;
            fartSound.currentTime = 0;
            fartSound.play().catch(()=>{});
        }
    }

    // Handgranate (F)
    else if (key === 'f') {
        if (now - lastSecondBombTime >= secondBombCooldown) {
            secondBombsArr.push({
                x: player.x + player.width / 2 - handgranateImg.width / 2,
                y: player.y,
                width: handgranateImg.width,
                height: handgranateImg.height,
                exploded: false,
                dx: 6,
                dy: -10,
                gravity: 0.5
            });

            lastSecondBombTime = now;

            const swooshSound = new Audio('sounds/swoosh.mp3');
            swooshSound.volume = 0.5;
            swooshSound.play().catch(()=>{});
        }
    }

    // Reset bei Game Over
    else if (e.key === 'Enter' && gameOverModal.style.display === 'block') {
        resetGame();
    }
}



function keyUpHandler(e) {

    if (e.key.toLowerCase() === 'd') rightPressed = false;
    else if (e.key.toLowerCase() === 'a') leftPressed = false;

    // Stretch loslassen
    else if (e.key === 'ArrowRight' && player.isStretched) {
        player.y += (player.height - player.originalHeight);
        player.height = player.originalHeight;
        player.isStretched = false;
        safePlay(stretchSound);
    }

    // MP40 loslassen
    else if (e.key === 'ArrowUp') {
        isShooting = false;
        mp40Sound.pause();
    }
}



// Sounds
const jumpSound=new Audio('sounds/jump.mp3');
const stretchSound=new Audio('sounds/stretch.mp3');
function safePlay(audio){audio.currentTime=0; audio.volume=0.6; audio.play().catch(()=>{});}
const fartSound = new Audio('sounds/fart.mp3');
fartSound.volume = 0.7;
const gameOverSound = new Audio('sounds/verenden.mp3');
gameOverSound.volume = 0.8;
// ---------------- MP40 Sound ----------------
const mp40Sound = new Audio('sounds/mp40.mp3');
mp40Sound.loop = true;
mp40Sound.volume = 0.4;














// Spielfigur wechseln
characterSelector.addEventListener('change',function(){
    playerImage.src=this.value;
    player.width=50; player.height=50; player.originalHeight=50;
    player.y=canvas.height-groundHeight-player.height + floorOffset;
    player.isStretched=false; player.dy=0; canvas.focus();
});


// ---------------- Hintergrundmusik ----------------
const mp3Files=['assets/mp3/song1.mp3','assets/mp3/song2.mp3','assets/mp3/song3.mp3'];
const audioPlayer=new Audio();
function playRandomSong(){
    if(audioPlayer.paused){
        const r=Math.floor(Math.random()*mp3Files.length);
        audioPlayer.src=mp3Files[r];
        audioPlayer.play().catch(()=>{});
    }
}
// ------------------ Alle JPGs aus einem Array laden ------------------
const backgroundFolder = 'assets/hintergrund/';
const backgroundFiles = [
    'hintergrund1.jpg',
    'hintergrund2.jpg',
    'hintergrund3.jpg',
	'hintergrund4.jpg',
	'hintergrund5.jpg',
	'hintergrund6.jpg',
	'hintergrund7.jpg',
	'hintergrund8.jpg',
    // f√ºge hier alle JPGs aus dem Ordner hinzu
];

const backgrounds = [];


backgroundFiles.forEach(file => {
    const img = new Image();
    img.src = backgroundFolder + file;
    backgrounds.push(img);
});








const backgroundImage = new Image();
setRandomBackground();





function setRandomBackground() {
    if (backgrounds.length === 0) return;
    const r = Math.floor(Math.random() * backgrounds.length);
    backgroundImage.src = backgrounds[r].src;
}

// ------------------ Hintergrund zeichnen mit Skalierung ------------------
function drawBackground() {
    if (!backgroundImage.complete) return;

    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    const imgWidth = backgroundImage.width;
    const imgHeight = backgroundImage.height;

    // Verh√§ltnis berechnen
    const scale = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);

    const drawWidth = imgWidth * scale;
    const drawHeight = imgHeight * scale;

    const offsetX = (canvasWidth - drawWidth) / 2;
    const offsetY = (canvasHeight - drawHeight) / 2;

    ctx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
}





// ---------------- Hindernisse ----------------


const normalObstacleWidth=60,normalObstacleHeight=60;
const werbungWidth=200,werbungHeight=100;
const bonusWidth=60,bonusHeight=100;
const superWidth=300, superHeight=133;

const obstacles=[];
const loadedObstacleImages=[]; 
['objekt1.png','objekt2.png','objekt3.png','objekt4.png','objekt5.png','objekt6.png','objekt7.png','objekt8.png','objekt9.png','objekt10.png','objekt11.png','objekt12.png'].forEach(img=>{const im=new Image(); im.src='assets/'+img; loadedObstacleImages.push(im);});
const loadedWerbungImages=[]; ['werbung1.png','werbung2.png','werbung3.png'].forEach(img=>{const im=new Image(); im.src='assets/werbung/'+img; loadedWerbungImages.push(im);});
const loadedBonusImages=[]; ['bonusgegner1.png','bonusgegner2.png','bonusgegner3.png','bonusgegner4.png','bonusgegner5.png','bonusgegner6.png'].forEach(img=>{const im=new Image(); im.src='assets/bonusgegner/'+img; loadedBonusImages.push(im);});
const loadedSuperImages=[]; ['supergegner1.png','supergegner2.png'].forEach(img=>{const im=new Image(); im.src='assets/supergegner/'+img; loadedSuperImages.push(im);});



// ---------------- Pakete f√ºr Elon ----------------
const packageImages = [];
const packageFiles = ['paket1.png','paket2.png','paket3.png']; // erweiterbar
packageFiles.forEach(file => {
    const img = new Image();
    img.src = 'assets/Pakete/' + file;
    packageImages.push(img);
});
const packages = []; // aktive Pakete
const packageFallSpeed = 4; // Fallgeschwindigkeit der Pakete


// ------------------ Ballons ------------------
const balloonImages = [];
const balloonFolder = 'assets/luftballons/';
const balloonFiles = [
    'luftballon1.png',
    'luftballon2.png',
    'luftballon3.png',
	'luftballon4.png',
	'luftballon5.png',
];

balloonFiles.forEach(file => {
    const img = new Image();
    img.src = balloonFolder + file;
    balloonImages.push(img);
});

let balloon = null;












// ---------------- Explosionen ----------------
const explosions=[];
function createPointExplosion(x, y, points){
    explosions.push({
        x, y, points, alpha:1, scale:0.5,
        vy: points.startsWith("+") ? -1.5 : 0,
        vx: (Math.random()-0.5)*1.5,
        rotation: (Math.random()-0.5)*0.2,
        shakePhase: 0
    });
}












// ---------------- Score / Level / Leben ----------------

let score=0, level=1, lives=3;
let gameSpeed = 1;  // Anfangsgeschwindigkeit
let obstacleSpeedBase = 3, obstacleSpeed = 3;
let bullets = [];
let isShooting = false;
let shootCooldown = 0;
let shooting = false;
let nextLevelScore = 10;










// ---------------- Bonus-, Super- & normale Objekte ----------------
let lastBonusTime = 0;
const bonusInterval = 20000; // 20 Sekunden

let lastSuperTime = 0;
const superInterval = 60000; // 60 Sekunden

let lastWerbungTime = 0;
const werbungInterval = 30000; // 30 Sekunden

let lastNormalTime = 0;
const normalInterval = 3000; // alle 3 Sekunden ein normales Hindernis

let nextObstacleTime = Date.now() + Math.random() * 3000 + 1000;




// ---------------- Sounds f√ºr Objekte ----------------
function playObjectSoundByName(image){
    if(!image || !image.src) return;
    const filename=image.src.split('/').pop().split('.')[0];
    const audio=new Audio(`sounds/${filename}.mp3`);
    audio.volume=0.5;
    audio.play().catch(()=>{});
}




	
	
	
// Hoppel-Animation bei Links/Rechtsbewegung
if ((rightPressed || leftPressed) && player.grounded) {
    hopping = true;
    hopPhase += hopSpeed;
	     const now = Date.now();
		 
		 
         if (now - lastBoingTime > 100) { // alle 0.3 Sekunden
         playBoing();
         lastBoingTime = now;
    }
	
	
} else {
    hopping = false;
    hopPhase = 0;
}






// ---------------- Hindernisse erzeugen ----------------

function checkCollision(p,o){
    return p.x < o.x + o.width &&
           p.x + p.width > o.x &&
           p.y < o.y + o.height &&
           p.y + p.height > o.y;
}

// ---------------- Hilfsfunktion: Kreis gegen Rechteck ----------------
function circleRectCollision(circle, rect) {
    // Finde den n√§chsten Punkt im Rechteck zum Kreismittelpunkt
    const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
    const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

    // Abstand vom Kreismittelpunkt zu diesem Punkt
    const dx = circle.x - closestX;
    const dy = circle.y - closestY;

    // Wenn Abstand kleiner als Radius ‚Üí Treffer
    return (dx * dx + dy * dy) <= (circle.radius * circle.radius);
}

function getBalloonHitbox() {
    if (!balloon) return null;
    return {
        x: balloon.x,
        y: balloon.y,
        width: balloon.image.width,
        height: balloon.image.height
    };
}


function checkRoundedRectCollision(rect1, rect2, radius = 15) {
    // Einfachheit: rechteckige Hitbox, Radius wird ber√ºcksichtigt f√ºr Ecken
    const dx = Math.max(rect2.x - rect1.x, 0, rect1.x + rect1.width - rect2.x - rect2.width);
    const dy = Math.max(rect2.y - rect1.y, 0, rect1.y + rect1.height - rect2.y - rect2.height);
    return (dx * dx + dy * dy) <= (radius * radius);
}

function getPlayerHitbox() {
    return {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
    };
}








function createObstacle() {
    const now = Date.now();

    // 1Ô∏è‚É£ Normales Hindernis pr√ºfen
    if (now - lastNormalTime >= normalInterval) {
        const randomIndex = Math.floor(Math.random() * loadedObstacleImages.length);
        const img = loadedObstacleImages[randomIndex];
        const isAlice = (randomIndex === 0);
        obstacles.push({
            x: canvas.width,
            y: canvas.height - groundHeight - normalObstacleHeight,
            width: normalObstacleWidth,
            height: normalObstacleHeight,
            image: img,
            isCollectible: isAlice,
			rotation: 0,            // Rotation starten
            rotationSpeed: -0.12     // Geschwindigkeit
			
			
			
			

        });
        lastNormalTime = now;
    } 
    // 2Ô∏è‚É£ Werbung pr√ºfen
    else if (now - lastWerbungTime >= werbungInterval) {
        const img = loadedWerbungImages[Math.floor(Math.random() * loadedWerbungImages.length)];
        obstacles.push({
            x: canvas.width,
            y: canvas.height - groundHeight - img.height, // baseY kann weg oder img.height benutzen
            baseY: canvas.height - groundHeight - img.height,
            width: img.width,   // Originalbreite
            height: img.height, // Originalh√∂he
            image: img,
            isWerbung: true,

        });
		playObjectSoundByName(img);
        lastWerbungTime = now;
    } 
    // 3Ô∏è‚É£ Bonusgegner pr√ºfen
    else if (now - lastBonusTime >= bonusInterval) {
        const img = loadedBonusImages[Math.floor(Math.random() * loadedBonusImages.length)];
        const baseY = canvas.height - groundHeight - bonusHeight;
        obstacles.push({
            x: canvas.width,
            y: canvas.height - groundHeight - img.height, // baseY kann weg oder img.height benutzen
            baseY: canvas.height - groundHeight - img.height,
            width: img.width,   // Originalbreite
            height: img.height, // Originalh√∂he
            image: img,
            isBonus: true,
            floatPhase: Math.random() * Math.PI * 2,
            glowPulse: Math.random() * Math.PI * 2
});
        playObjectSoundByName(img);
        lastBonusTime = now;
    } 
    // 4Ô∏è‚É£ Supergegner pr√ºfen
    else if (now - lastSuperTime >= superInterval) {
        const img = loadedSuperImages[Math.floor(Math.random() * loadedSuperImages.length)];
        obstacles.push({
            x: canvas.width,
            y: canvas.height - groundHeight - img.height + floorOffset,
            width: superWidth,
            height: superHeight,
            image: img,
            isSuper: true,
            dx: -(obstacleSpeed + 1)
        });
        playObjectSoundByName(img);
        lastSuperTime = now;
    }
}






// ---------------- Obstacles bewegen & Kollision ----------------
function moveObstacles() {
    const now = Date.now();

    // Neue Hindernisse erzeugen
    if (!gamePaused && now > nextObstacleTime) {
        createObstacle();
        nextObstacleTime = now + Math.random() * 4000 + 1000;
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];

        // Bewegung
        if (o.isSuper) o.x += o.dx;
        else o.x -= obstacleSpeed;

        // ---------------- KOLLISION ----------------
        const collisionRadius = Math.min(o.width, o.height)/2; // Radius f√ºr abgerundetes Rechteck
        if (checkRoundedRectCollision(getPlayerHitbox(), o, Math.min(o.width, o.height)/2)) {

            // Werbung ignorieren
            if (o.isWerbung) continue;

            // Sammelobjekt
            if (o.isCollectible) {
                if (player.isStretched) {
                    score++;
                    scoreElement.textContent = score;
                    createPointExplosion(o.x + o.width / 2, o.y, "+1");
                    playRandomSong();

                    if (score % 10 === 0) {
                        level++;
                        levelElement.textContent = level;
                        obstacleSpeed += 1;
                    }
                }
                obstacles.splice(i, 1);
            }
            // Bonusgegner
            else if (o.isBonus) {
                obstacles.splice(i, 1);
                gameOver();
            }
            // Supergegner
            else if (o.isSuper) {
                lives--;
                livesElement.textContent = lives;
                createPointExplosion(player.x + player.width / 2, player.y, "-1 Leben");
                obstacles.splice(i, 1);
                if (lives <= 0) gameOver();
            }
            // Normales Hindernis
            else {
                lives--;
                livesElement.textContent = lives;
                createPointExplosion(player.x + player.width / 2, player.y, "-1 Leben");
                obstacles.splice(i, 1);
                if (lives <= 0) gameOver();
            }

            continue;
        }

        // Bildschirm verlassen ‚Üí entfernen
        if (o.x + o.width < 0) {
            obstacles.splice(i, 1);
        }
    }
}





// ---------------- Ballon Spawn ----------------
function spawnBalloon() {
    if (balloonImages.length === 0) return;

    const img = balloonImages[Math.floor(Math.random() * balloonImages.length)];

    balloon = {
        image: img,
        x: -img.width,
        baseY: canvas.height / 2 - img.height / 2,
        y: canvas.height / 2 - img.height / 2,
        speed: 0.8,
        floatPhase: Math.random() * Math.PI * 2,
        floatAmplitude: 15,
        windPhase: Math.random() * Math.PI * 2,

        // ‚ù§Ô∏è NEU
        health: 100,
        maxHealth: 100,
        showHealth: false,
        healthTimer: 0
    };
}



function updateBalloon() {
    if (!balloon) return;

    balloon.x += balloon.speed;

    // Vertikales Schweben
    balloon.floatPhase += 0.02;
    const floatOffset = Math.sin(balloon.floatPhase) * balloon.floatAmplitude;

    // Wind-Schaukel
    balloon.windPhase += 0.015;
    const windOffset = Math.sin(balloon.windPhase) * 10;

    balloon.y = balloon.baseY + floatOffset;

    // üìä Lebensbalken-Timer
    if (balloon.showHealth) {
        balloon.healthTimer--;
        if (balloon.healthTimer <= 0) {
            balloon.showHealth = false;
        }
    }

    // Wenn komplett drau√üen ‚Üí neuer Ballon
    if (balloon.x > canvas.width + balloon.image.width) {
        spawnBalloon();
    }

    balloon.windOffset = windOffset;
}



function drawBalloon() {
    if (!balloon) return;

    ctx.save();

    ctx.translate(
        balloon.x + balloon.image.width / 2,
        balloon.y + balloon.image.height / 2
    );

    ctx.rotate(balloon.windOffset * 0.01);

    ctx.drawImage(
        balloon.image,
        -balloon.image.width / 2,
        -balloon.image.height / 2
    );

    ctx.restore();

    // ‚ù§Ô∏è Lebensbalken (NICHT rotiert)
    if (balloon.showHealth) {

        const barWidth = balloon.image.width;
        const barHeight = 6;
        const percent = balloon.health / balloon.maxHealth;

        // Hintergrund (rot)
        ctx.fillStyle = "red";
        ctx.fillRect(
            balloon.x,
            balloon.y - 10,
            barWidth,
            barHeight
        );

        // Aktuelles Leben (gr√ºn)
        ctx.fillStyle = "lime";
        ctx.fillRect(
            balloon.x,
            balloon.y - 10,
            barWidth * percent,
            barHeight
        );
    }
}











// ------------------ Bomben (Handgranaten) ------------------
const bombsArr = [], bombSize = 20, bombFallSpeed = 5, bombExplosionRadius = 30, bombCooldown = 10000; 
let lastBombTime = -bombCooldown;

const secondBombsArr = [], secondBombSize = 25, secondBombFallSpeed = 5, secondBombExplosionRadius = 30, secondBombCooldown = 10000;
let lastSecondBombTime = -secondBombCooldown;

const dynamitImg = new Image(); 
dynamitImg.src = 'assets/dynamit.png';

const handgranateImg = new Image(); 
handgranateImg.src = 'assets/handgranate.png';

const dynamitSound = new Audio('sounds/dynamit.mp3');
const handgranateSound = new Audio('sounds/handgranate.mp3');
const smokeParticles = [];

// ------------------ Smoke ------------------
function createSmoke(x,y){ smokeParticles.push({x,y,radius:Math.random()*5+5,alpha:0.5,vy:-1-(Math.random()),vx:(Math.random()-0.5)*1,life:50,color:'gray'}); }
function updateSmoke(){ for(let i=smokeParticles.length-1;i>=0;i--){ const s=smokeParticles[i]; s.x+=s.vx; s.y+=s.vy; s.alpha-=0.01; s.radius*=0.98; s.life--; if(s.alpha<=0||s.life<=0) smokeParticles.splice(i,1); } }
function drawSmoke(){ smokeParticles.forEach(s=>{ ctx.save(); ctx.globalAlpha=s.alpha; ctx.fillStyle=s.color; ctx.beginPath(); ctx.arc(s.x,s.y,s.radius,0,Math.PI*2); ctx.fill(); ctx.restore(); }); }







// ---------------- Spielereingaben ----------------


document.addEventListener('keydown',keyDownHandler);
document.addEventListener('keyup',keyUpHandler);

document.addEventListener('keydown', function (e) {
    const now = Date.now();

    // Normale Handgranate ‚Äì E
    if (e.key.toLowerCase() === 'e') {
        if (now - lastBombTime >= bombCooldown) {
bombsArr.push({
    x: player.x,
    y: player.y,
    width: dynamitImg.naturalWidth,
    height: dynamitImg.naturalHeight,
    exploded: false,
    explosionFrame: 0,
    damageDone: false,
    spawnTime: Date.now()
});

            lastBombTime = now;
            fartSound.currentTime = 0;
            fartSound.play().catch(() => {});
        }
    }

// Zweite Granate ‚Äì Taste F
if (e.key.toLowerCase() === 'f') {
    if (now - lastSecondBombTime >= secondBombCooldown) {
secondBombsArr.push({
    x: player.x + player.width / 2 - handgranateImg.width / 2,
    y: player.y,
    width: handgranateImg.width,    // Originalbreite
    height: handgranateImg.height,  // Originalh√∂he
    exploded: false,
    dx: 6,
    dy: -10,
    gravity: 0.5
});

        lastSecondBombTime = now;

        // Sound beim Werfen abspielen
        const swooshSound = new Audio('sounds/swoosh.mp3');
        swooshSound.volume = 0.5; // Lautst√§rke anpassen
        swooshSound.play().catch(() => {});
    }
}
});





// ------------------ Update & Draw normale Bomben ------------------
function updateBombs() {

    for (let i = bombsArr.length - 1; i >= 0; i--) {

        const b = bombsArr[i];

        // ---------------------------
        // üß® NOCH NICHT EXPLODIERT
        // ---------------------------
        if (!b.exploded) {

            // Bombe f√§llt
            if (b.y + b.height < canvas.height - groundHeight) {
                b.y += bombFallSpeed;
                createSmoke(b.x + b.width / 2, b.y);
            }

            // ‚è± Explosion nach 3 Sekunden
            if (Date.now() - b.spawnTime >= 3000) {
                b.exploded = true;
                b.explosionFrame = 0;
                b.damageDone = false;
                safePlay(dynamitSound);
            }

        }

        // ---------------------------
        // üí• EXPLOSION L√ÑUFT
        // ---------------------------
        else {

            b.explosionFrame++;

            const radius = Math.min(
                bombExplosionRadius,
                b.explosionFrame * 2
            );

            // Explosion zeichnen
            ctx.save();
            ctx.globalAlpha = 1 - (radius / bombExplosionRadius);
            ctx.fillStyle = 'orange';
            ctx.beginPath();
            ctx.arc(
                b.x + b.width / 2,
                b.y + b.height / 2,
                radius,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.restore();

            // Schaden nur einmal
            if (!b.damageDone && radius >= 15) {

                b.damageDone = true;

                for (let j = obstacles.length - 1; j >= 0; j--) {

                    const o = obstacles[j];

                    const dx = (b.x + b.width/2) - (o.x + o.width/2);
                    const dy = (b.y + b.height/2) - (o.y + o.height/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist <= radius + o.width/2) {

                        // Gegner entfernen
                        obstacles.splice(j, 1);

                        // Leben erh√∂hen
                        lives++;
                        livesElement.textContent = lives;

                        createPointExplosion(
                            o.x + o.width/2,
                            o.y,
                            "+1 Leben"
                        );
                    }
                }
            }

            // Explosion beenden
            if (b.explosionFrame > 30) {
                bombsArr.splice(i, 1);
            }
        }
    }

    // ---------------------------
    // üîπ Dynamit-Cooldown Anzeige
    // ---------------------------

    const remainingDynamit = Math.max(
        0,
        Math.ceil((bombCooldown - (Date.now() - lastBombTime)) / 1000)
    );

    dynamitDisplay.textContent =
        remainingDynamit > 0
            ? `Dynamit: ${remainingDynamit}s`
            : 'Dynamit bereit!';
}








function drawBombs(){ 
    bombsArr.forEach(b => { 
        if (!b.exploded) {
            ctx.drawImage(dynamitImg, b.x, b.y + floorOffset);
        }
    });

    drawSmoke(); 
}


// ------------------ Bomben (Handgranaten) ------------------
function updateSecondBombs() {

    for (let i = secondBombsArr.length - 1; i >= 0; i--) {

        const b = secondBombsArr[i];

        if (!b.exploded) {

            // Bewegung
            b.x += b.dx;
            b.y += b.dy;
            b.dy += b.gravity;

            // üî• Nur Supergegner pr√ºfen
            for (let j = obstacles.length - 1; j >= 0; j--) {
                const o = obstacles[j];

                if (o.isSuper && checkCollision(b, o)) {

                    obstacles.splice(j, 1);

                    b.exploded = true;

                    handgranateSound.currentTime = 0;
                    handgranateSound.play().catch(() => {});

                    break;
                }
            }

            // ‚ùå KEINE Boden-Explosion mehr
            // ‚ùå Keine Explosion ohne Supergegner

            // Wenn komplett aus Bildschirm ‚Üí einfach entfernen
            if (
                b.x > canvas.width ||
                b.x + b.width < 0 ||
                b.y > canvas.height
            ) {
                secondBombsArr.splice(i, 1);
            }

        } else {

            // Kurzer visueller Effekt
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = 'purple';
            ctx.beginPath();
            ctx.arc(
                b.x + b.width / 2,
                b.y + b.height / 2,
                secondBombExplosionRadius,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.restore();

            secondBombsArr.splice(i, 1);
        }
    }

    // Cooldown Anzeige
    const remainingGrenade = Math.max(
        0,
        Math.ceil((secondBombCooldown - (Date.now() - lastSecondBombTime)) / 1000)
    );

    grenadeDisplay.textContent =
        remainingGrenade > 0
            ? `Handgranate: ${remainingGrenade}s`
            : 'Handgranate bereit!';
}
function drawSecondBombs(){
    secondBombsArr.forEach(b=>{ if(!b.exploded) ctx.drawImage(handgranateImg, b.x, b.y, b.width, b.height); });
}

// ---------------- Elon-Rakete ----------------
const offscreen = 300; // wie weit Elon aus dem Bildschirm rausfliegen soll

const rocketSmokeParticles=[];
function createRocketSmoke(x,y){
    rocketSmokeParticles.push({
        x,y,
        radius:Math.random()*12+8,
        alpha:0.5+Math.random()*0.3,
        vx:-(Math.random()*1.5+1),
        vy:(Math.random()-0.5)*0.5,
        life:110+Math.random()*40
    });
}
function updateRocketSmoke(){
    for(let i=rocketSmokeParticles.length-1;i>=0;i--){
        const s=rocketSmokeParticles[i];
        s.x+=s.vx; s.y+=s.vy; s.radius*=0.97; s.alpha*=0.985; s.life--;
        if(s.life<=0) rocketSmokeParticles.splice(i,1);
    }
}
function drawRocketSmoke(){
    rocketSmokeParticles.forEach(s=>{
        ctx.save();
        ctx.globalAlpha=s.alpha;
        ctx.fillStyle='rgba(200,200,200,0.6)';
        ctx.beginPath();
        ctx.arc(s.x,s.y,s.radius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
    });
}

const elonImage=new Image();
elonImage.src='assets/elon.PNG';
let elon={x:0,y:50,width:300,height:136,speed:2,direction:1,waiting:false,floatPhase:0,floatAmplitude:10,glowPhase:0};











function drawElon(){
    // Float-Bewegung
    elon.floatPhase+=0.1;
    const floatY=Math.sin(elon.floatPhase)*elon.floatAmplitude+Math.sin(elon.floatPhase*1.7+1)*elon.floatAmplitude/2;

    ctx.save();
    ctx.translate(elon.x, elon.y+floatY);
    if(elon.direction===-1){ctx.translate(elon.width,0); ctx.scale(-1,1);}
    
    // Glow
    elon.glowPhase+=0.1;
    const glowPower=10+Math.sin(elon.glowPhase)*5;
    ctx.shadowColor='red';
    ctx.shadowBlur=glowPower;
    ctx.shadowOffsetX=0;
    ctx.shadowOffsetY=0;

    ctx.drawImage(elonImage,0,0,elon.width,elon.height);

    // Rauch
    const smokeX=elon.width*0.27, smokeY=elon.height*0.5;
    createRocketSmoke(smokeX, smokeY);
    updateRocketSmoke();
    drawRocketSmoke();
    ctx.restore();

    // Bewegung + Wartezeit
    if(!elon.waiting){
        elon.x += elon.speed*elon.direction;

        // Pr√ºfen, ob Elon komplett aus dem Bildschirm raus ist + offscreen
        if((elon.direction===1 && elon.x > canvas.width + offscreen) || 
           (elon.direction===-1 && elon.x + elon.width < -offscreen)) {

            elon.waiting = true; // Wartezeit starten

            setTimeout(() => {
                elon.direction *= -1;
                elon.x = elon.direction===1 ? -elon.width - offscreen : canvas.width + offscreen;
                elon.waiting = false;
            }, 5000); // ‚Üê 5 Sekunden warten
        }
    }
}

let lastPackageTime = 0;      // Zeitpunkt, wann zuletzt ein Paket droppt
const packageCooldown = 10000; // Millisekunden zwischen Paketen (1 Sekunde)
const maxPackages = 3;        // Maximal gleichzeitig aktive Pakete







function maybeDropPackage() {

    const now = Date.now();
    const midX = canvas.width / 2;
    const elonCenterX = elon.x + elon.width / 2;
    const middleZone = 250; // Bereich, in dem Elon Pakete droppen darf

    // Wenn zu viele Pakete aktiv sind, nichts tun
    if(packages.length >= maxPackages) return;

    // Pr√ºfen, ob Elon in der Mittelzone ist
    if(Math.abs(elonCenterX - midX) < middleZone) {
        // Cooldown pr√ºfen
        if(now - lastPackageTime > packageCooldown) {
            const img = packageImages[Math.floor(Math.random() * packageImages.length)];
            packages.push({
                x: elon.x + elon.width/2 - img.width/2,
                y: elon.y + elon.height,
                width: img.width,
                height: img.height,
                image: img
            });
            lastPackageTime = now; // Zeitpunkt merken
        }
    }
}







// ---------------- Pakete bewegen & zeichnen ----------------
function updatePackages() {
    for (let i = packages.length - 1; i >= 0; i--) {
        const p = packages[i];

        // Paket f√§llt nach unten mit fixer Geschwindigkeit
        p.y += packageFallSpeed;

        // Paket aus dem Bildschirm entfernen, wenn es ganz unten rausf√§llt
        if (p.y > canvas.height) {
            packages.splice(i, 1);
            continue;
        }

        // Kollision mit Spieler pr√ºfen
        if (checkCollision(player, p)) {
            score += 1; 
            scoreElement.textContent = score;
            createPointExplosion(p.x + p.width/2, p.y + p.height/2, "+1");

            // ‚úÖ Sound beim Einsammeln abspielen
            const packageSound = new Audio('sounds/pakete.mp3');
            packageSound.volume = 0.5; // Lautst√§rke nach Bedarf
            packageSound.play().catch(() => {});

            packages.splice(i, 1); // Paket eingesammelt
        }
    }
}






function drawPackages() {
    packages.forEach(p => ctx.drawImage(p.image, p.x, p.y, p.width, p.height));
}





// ---------------- Wetter-System ----------------
let weatherType = null, weatherParticles = [], maxWeatherParticles = 150, wind = 0, windTarget = 0, windChangeSpeed = 0.002, thunderTimer = 0, thunderFlash = false;
const thunderSounds = [new Audio('sounds/thunder1.mp3'), new Audio('sounds/thunder2.mp3'), new Audio('sounds/thunder3.mp3')];
function playThunderSound(){const thunder = thunderSounds[Math.floor(Math.random()*thunderSounds.length)]; const delay = 200+Math.random()*800; setTimeout(()=>{thunder.volume=0.6; thunder.play().catch(()=>{});},delay);}
function setRandomWeather(){
    const r=Math.random();
    if(r<0.25) weatherType=null;
    else if(r<0.5) weatherType='rain';
    else if(r<0.8) weatherType='snow';
    else weatherType='thunder';
    if(!weatherType){ weatherParticles=[]; return; }
    maxWeatherParticles = weatherType==='snow'?100+Math.random()*50:150+Math.random()*100;
    wind=(Math.random()-0.5)*2; windTarget=wind;
    weatherParticles=[];
    for(let i=0;i<maxWeatherParticles;i++){
        weatherParticles.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,speedY:weatherType==='rain'?4+Math.random()*4:1+Math.random()*2,size:weatherType==='rain'?2:3+Math.random()*3,rotation:Math.random()*Math.PI*2,rotationSpeed:Math.random()*0.02-0.01});
    }
    thunderTimer=weatherType==='thunder'?100+Math.random()*200:0;
}







function updateWeather(){
    if(!weatherType) return;
    wind+=(windTarget-wind)*windChangeSpeed;
    if(Math.abs(wind-windTarget)<0.01) windTarget=(Math.random()-0.5)*2*(1+(level-1)*0.05);
    for(let p of weatherParticles){p.y+=p.speedY; p.x+=wind; if(weatherType==='snow') p.rotation+=p.rotationSpeed; if(p.y>canvas.height){p.y=-10; p.x=Math.random()*canvas.width;} if(p.x<0)p.x=canvas.width; if(p.x>canvas.width)p.x=0;}
    if(weatherType==='thunder'){thunderTimer--; if(thunderTimer<=0){thunderFlash=true; playThunderSound(); setTimeout(()=>{thunderFlash=false; thunderTimer=Math.max(50,100-(level-1)*5)+Math.random()*100;},100+Math.random()*200);}}
}






function drawWeather(){
    if(!weatherType) return;
    if(thunderFlash){ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fillRect(0,0,canvas.width,canvas.height);}
    let intensityMultiplier=1+(level-1)*0.1;
    ctx.save();
    for(let p of weatherParticles){
        let px=p.x, py=p.y;
        if(weatherType==='rain'||weatherType==='thunder'){ctx.strokeStyle='rgba(173,216,230,0.6)'; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px,py+p.size*5*intensityMultiplier); ctx.stroke();}
        else if(weatherType==='snow'){ctx.save(); ctx.translate(px,py); ctx.rotate(p.rotation); ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(0,0,p.size*intensityMultiplier,0,Math.PI*2); ctx.fill(); ctx.restore();}
    }
    ctx.restore();
}



// ---------------- Draw Player ----------------

function drawPlayer(){
    let hopOffset = hopping ? Math.abs(Math.sin(hopPhase))*hopHeight : 0;

    if (isShooting) {
        ctx.drawImage(playerFireImage, player.x, player.y - hopOffset, player.width, player.height);
    } else {
        ctx.drawImage(playerImage, player.x, player.y - hopOffset, player.width, player.height);
    }
}









function drawGround(){
        const stripeWidth=40,stripeHeight=5,stripeGap=20; ctx.fillStyle='#2f2f2f'; platforms.forEach(p=>{ctx.fillRect(p.x,p.y,p.width,p.height); for(let x=p.x;x<p.x+p.width;x+=stripeWidth+stripeGap){ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(x,p.y+p.height/2-stripeHeight/2,stripeWidth,stripeHeight);}});}





// Hindernisse bewegen & zeichnen
function drawObstacles(){
    obstacles.forEach(o => {
        const drawY = o.y + floorOffset;

        if(o.isBonus){
            o.floatPhase += 0.08;
            const floatY = Math.sin(o.floatPhase) * 15;
            ctx.save();
            ctx.drawImage(o.image, o.x, o.baseY - floatY, o.width, o.height);
            ctx.restore();
        }
        else if(o.isSuper || o.isWerbung){
            ctx.drawImage(o.image, o.x, drawY, o.width, o.height);
        }
        else { // Normale Objekte: rotieren
            o.rotation += o.rotationSpeed;
            ctx.save();
            ctx.translate(o.x + o.width/2, drawY + o.height/2);
            ctx.rotate(o.rotation);
            ctx.drawImage(o.image, -o.width/2, -o.height/2, o.width, o.height);
            ctx.restore();
        }
		

    });
	
}




function drawExplosions(){
         for(let i=explosions.length-1;i>=0;i--){
		 const e=explosions[i]; ctx.save(); 
		 ctx.globalAlpha=e.alpha; ctx.translate(e.x,e.y); 
		 let shakeOffsetX=0,shakeOffsetY=0; if(e.points.startsWith("-")){e.shakePhase+=0.3; shakeOffsetX=Math.sin(e.shakePhase*5)*5; shakeOffsetY=Math.sin(e.shakePhase*3)*3;} ctx.translate(shakeOffsetX,shakeOffsetY); ctx.rotate(e.rotation); ctx.fillStyle=e.points.startsWith("+")?'gold':e.points.startsWith("-")?'red':'white'; ctx.font=`${28*e.scale}px Arial`; ctx.textAlign='center'; ctx.fillText(e.points,0,0); ctx.restore(); e.y+=e.vy; e.x+=e.vx; e.alpha-=0.03; e.scale+=0.03; e.rotation+=0.05; if(e.alpha<=0) explosions.splice(i,1);}}







// ---------------- Shooting System ----------------

function shootBullet() {
    bullets.push({
        x: player.x + player.width / 2,
        y: player.y,
        radius: 3,
        speed: 10
    });
}

function updateBullets() {

    // Schussrate begrenzen
    if (isShooting) {
        shootCooldown--;
        if (shootCooldown <= 0) {
            shootBullet();
            shootCooldown = 8; // Feuerrate
        }
    }

    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];

        b.y -= b.speed;

// Ballon Treffer?
if (balloon &&
    b.x > balloon.x &&
    b.x < balloon.x + balloon.image.width &&
    b.y > balloon.y &&
    b.y < balloon.y + balloon.image.height) {

    bullets.splice(i, 1);

    // ‚ù§Ô∏è Schaden
    balloon.health--;

    // Balken anzeigen
    balloon.showHealth = true;
    balloon.healthTimer = 60;

    // Wenn tot ‚Üí zerst√∂ren + neu spawnen
    if (balloon.health <= 0) {
        score++;
        spawnBalloon();
    }

    continue;
}

        // aus Bildschirm entfernen
        if (b.y < 0) {
            bullets.splice(i, 1);
        }
    }
}



function drawBullets() {
    ctx.fillStyle = "#555";

    bullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
    });
}













// ---------------- Game Loop ----------------

function updateGameArea() {
    if (gamePaused) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Hintergrund & Ballon
    drawBackground();

    // Spieler & Hindernisse
    movePlayer();
    moveObstacles();

    // Pakete & Bomben & Bullets
    updatePackages();
    updateBombs();
    updateSecondBombs();
    maybeDropPackage();
	updateBullets();
    drawBullets();

    // Zeichnen
    drawGround();
    drawObstacles();
    drawPackages();
    drawBombs();
	updateBalloon();
	drawBalloon();
    drawSecondBombs();
    drawPlayer();
    drawExplosions();
    drawElon();

    // Wetter
    drawWeather();
    updateWeather();
	
	
	
	
	// ---------------- Level-Up ----------------
if (score >= nextLevelScore) {
    level++;
    nextLevelScore += 10;

    gameSpeed += 0.2;  // alles wird schneller
    obstacleSpeed = obstacleSpeedBase * gameSpeed;

    console.log("Level:", level, "Speed:", gameSpeed);
}
	
	
	
	
	
	
}











function gameLoop() {
    updateGameArea();    // bestehendes Update f√ºr Hindernisse, Pakete, Ballon etc.

    if (!gamePaused) {
        movePlayer();    // ‚Üê NEU: berechnet jetzt Bewegung, Sprung, H√ºpfen
        drawPlayer();    // ‚Üê Spieler rendern
        // optional: andere Draw-Funktionen wie drawObstacles(), drawPackages(), drawBackground() bleiben hier
        requestAnimationFrame(gameLoop);
    }
}

		 



// ---------------- Reset & Game Over ----------------
function resetGame(){
    player.x=50; player.y=canvas.height-player.height-groundHeight+floorOffset;
    player.dx=0; player.dy=0; player.jumps=0; player.grounded=false; player.isStretched=false;
    obstacles.length=0; score=0; scoreElement.textContent=score;
    level=1; levelElement.textContent=level;
    lives=3; livesElement.textContent=lives;
    gameOverModal.style.display='none';
    obstacleSpeed=obstacleSpeedBase; gamePaused=false;
	setRandomWeather();
    canvas.focus();
	playRandomTitelmusik();
    spawnBalloon();	
    gameLoop();
	
	
	
	
	
	
	
	
}
function gameOver(){
safePlay(gameOverSound);
gamePaused=true; 
gameOverModal.style.display='block'; 
if(score>highscore){highscore=score; localStorage.setItem('highscore',highscore); highscoreElement.textContent=highscore;}}
restartButton.addEventListener('click',resetGame);




// ---------------- Resize ----------------

canvas.width = FIELD_WIDTH;
canvas.height = FIELD_HEIGHT;
platforms[0].y = canvas.height - groundHeight;

// ---------------- Initialisierung ----------------

canvas.focus();
setRandomWeather();
spawnBalloon();
gameLoop();
</script>
</body>
</html>